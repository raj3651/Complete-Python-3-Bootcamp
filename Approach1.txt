
@RestController
@RequestMapping("/api/v1/files")
@RequiredArgsConstructor
@Slf4j
public class SecureChunkedDownloadController {

    // AWS S3 client (v2 SDK) — handles SSE-S3, SSE-KMS, CSE-KMS transparently
    private final S3Client s3;

    // Your encrypted bucket name (SSE-S3 or SSE-KMS enabled)
    private final String bucket = "your-encrypted-research-bucket";

    // Max 10 MB per chunk — exactly matches API Gateway REST API hard limit
    private static final long CHUNK_SIZE = 10_485_760L; // 10 * 1024 * 1024

    // Thread-safe SHA-256 digest for checksum calculation
    private static final MessageDigest SHA256;

    static {
        try {
            SHA256 = MessageDigest.getInstance("SHA-256");
        } catch (NoSuchAlgorithmException e) {
            throw new ExceptionInInitializerError("SHA-256 not available");
        }
    }

    /**
     * Main endpoint: streams one chunk of a file from S3
     * Supports parallel calls with different offsets
     */
    @GetMapping(value = "/{fileId}/download", produces = MediaType.APPLICATION_OCTET_STREAM_VALUE)
    public ResponseEntity<StreamingResponseBody> downloadChunk(
            @PathVariable String fileId,                    // Unique file identifier (e.g., UUID)
            @RequestParam(defaultValue = "0") long offset,  // Byte offset to start reading from
            @AuthenticationPrincipal Jwt jwt) {             // Authenticated user (Cognito/JWT)

        // Extract user ID from JWT token for audit/access control
        String userId = jwt.getSubject();

        // Validate user has access + log access attempt (critical for compliance)
        FileMetadata meta = fileService.validateAndLogAccess(userId, fileId);

        // S3 object key (path inside bucket)
        String key = meta.s3Key(); // e.g., "encrypted/2025/model-v2.bin"

        // Get total file size via HEAD request (fast, no data transfer)
        long fileSize = getObjectSize(key);

        // Calculate end byte of this chunk (inclusive)
        long end = Math.min(offset + CHUNK_SIZE - 1, fileSize - 1);

        // Determine if there's more data after this chunk
        long nextOffset = end + 1 < fileSize ? end + 1 : -1;

        // Compute SHA-256 checksum of *only this byte range* (for integrity)
        String partChecksum = computePartChecksum(key, offset, end);

        // Build response headers — client uses these for resume & verification
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_OCTET_STREAM);
        headers.set("Accept-Ranges", "bytes");                    // Tells client we support ranges
        headers.set("X-File-Size", String.valueOf(fileSize));     // Total file size in bytes
        headers.set("X-Full-Checksum", meta.sha256());            // Pre-computed full file SHA-256
        headers.set("X-Part-Checksum", partChecksum);             // This chunk's SHA-256 (Base64)
        headers.set("X-Chunk-Start", String.valueOf(offset));    // Start byte of this chunk
        headers.set("X-Chunk-End", String.valueOf(end));          // End byte of this chunk
        headers.set("X-Filename", URLEncoder.encode(meta.filename(), UTF_8));

        // Tell client if more chunks exist
        if (nextOffset > 0) {
            headers.set("X-Next-Offset", String.valueOf(nextOffset));
            headers.set("X-Has-More", "true");
        } else {
            headers.set("X-Has-More", "false");
        }

        // Streaming body — streams directly from S3 → API Gateway → Client
        StreamingResponseBody stream = outputStream -> {
            GetObjectRequest s3Request = GetObjectRequest.builder()
                    .bucket(bucket)
                    .key(key)
                    .range("bytes=" + offset + "-" + end)  // S3 Range GET — only downloads this chunk
                    .build();

            // Stream directly from S3 to HTTP response (zero buffering)
            try (ResponseInputStream<GetObjectResponse> s3Stream = s3.getObject(s3Request)) {
                s3Stream.transferTo(outputStream);  // Efficient zero-copy transfer
            }
        };

        // Log successful chunk delivery
        log.info("Delivering chunk [{}-{}] of {} (size: {} bytes) to user {}", 
                offset, end, key, (end - offset + 1), userId);

        // Return 206 Partial Content — standard for range requests
        return ResponseEntity.status(HttpStatus.PARTIAL_CONTENT)
                .headers(headers)
                .contentLength(end - offset + 1)
                .body(stream);
    }

    // Fast HEAD request to get file size without downloading
    private long getObjectSize(String key) {
        return s3.headObject(b -> b.bucket(bucket).key(key)).contentLength();
    }

    // Compute SHA-256 of a specific byte range in S3 (used for part verification)
    private String computePartChecksum(String key, long start, long end) {
        GetObjectRequest req = GetObjectRequest.builder()
                .bucket(bucket).key(key)
                .range("bytes=" + start + "-" + end)
                .build();

        try (ResponseInputStream<GetObjectResponse> stream = s3.getObject(req)) {
            MessageDigest digest = (MessageDigest) SHA256.clone(); // Thread-safe clone
            byte[] buffer = new byte[8192];
            int read;
            while ((read = stream.read(buffer)) != -1) {
                digest.update(buffer, 0, read);
            }
            return Base64.getEncoder().encodeToString(digest.digest());
        } catch (Exception e) {
            throw new RuntimeException("Failed to compute part checksum", e);
        }
    }
}


------------------

public class SecureParallelDownloader {

    private static final long CHUNK_SIZE = 10_485_760L; // Must match server
    private final HttpClient client;
    private final String baseUrl;
    private final String token;
    private final int threadCount;

    public SecureParallelDownloader(String baseUrl, String token, int threads) {
        this.baseUrl = baseUrl;
        this.token = token;
        this.threadCount = threads;
        this.client = HttpClient.newBuilder()
                .executor(Executors.newVirtualThreadPerTaskExecutor()) // JDK 21 = unlimited threads
                .connectTimeout(Duration.ofSeconds(30))
                .build();
    }

    public record DownloadStats(long bytes, Duration time, String sha256) {}

    public DownloadStats download(String fileId, Path outputFile) throws Exception {
        long startTime = System.nanoTime();

        // Step 1: Get file metadata (size + expected full checksum)
        var meta = fetchMetadata(fileId);
        long totalSize = meta.size;
        String expectedFullSha = meta.fullSha;

        // Ensure output directory exists
        Files.createDirectories(outputFile.getParent());

        // Resume support: track which chunks are already downloaded
        Path progressFile = outputFile.resolveSibling(outputFile.getFileName() + ".progress");
        Set<Long> completedChunks = loadCompletedChunks(progressFile);

        // Calculate missing offsets
        List<Long> missingOffsets = LongStream.range(0, (totalSize + CHUNK_SIZE - 1) / CHUNK_SIZE)
                .map(i -> i * CHUNK_SIZE)
                .filter(offset -> !completedChunks.contains(offset))
                .boxed()
                .toList();

        // Track total downloaded bytes for progress bar
        AtomicLong downloadedBytes = new AtomicLong(
            completedChunks.stream()
                .mapToLong(offset -> Math.min(offset + CHUNK_SIZE, totalSize) - offset)
                .sum()
        );

        // Parallel download with fixed thread pool
        try (var executor = Executors.newFixedThreadPool(threadCount)) {
            List<CompletableFuture<Void>> futures = missingOffsets.stream()
                .map(offset -> CompletableFuture.runAsync(() ->
                    downloadAndVerifyChunk(fileId, offset, totalSize, outputFile, downloadedBytes, progressFile),
                    executor))
                .toList();

            // Live progress bar
            while (!CompletableFuture.allOf(futures.toArray(new CompletableFuture[0])).isDone()) {
                double percent = 100.0 * downloadedBytes.get() / totalSize;
                System.out.printf("\r[%-50s] %.2f%% – %s / %s",
                    "█".repeat((int) (percent / 2)),
                    percent,
                    formatBytes(downloadedBytes.get()),
                    formatBytes(totalSize));
                Thread.sleep(100);
            }
        }

        System.out.println("\nDownload complete. Verifying integrity...");

        // Final SHA-256 verification of entire file
        String actualSha = computeFileSha256(outputFile);
        if (!actualSha.equals(expectedFullSha)) {
            throw new IOException("CORRUPTION DETECTED: SHA-256 mismatch!");
        }

        // Cleanup progress file
        if (Files.exists(progressFile)) Files.delete(progressFile);

        Duration duration = Duration.ofNanos(System.nanoTime() - startTime);
        System.out.printf("SUCCESS: %s verified in %s (%s/s)%n",
                outputFile.getFileName(),
                formatDuration(duration),
                formatBytes(totalSize / Math.max(1, duration.toSeconds())) + "/s");

        return new DownloadStats(totalSize, duration, actualSha);
    }

    private record FileMetadata(long size, String fullSha) {}

    private FileMetadata fetchMetadata(String fileId) throws Exception {
        var request = HttpRequest.newBuilder()
                .uri(URI.create(baseUrl + "/api/v1/files/" + fileId + "/download"))
                .header("Authorization", "Bearer " + token)
                .method("HEAD", HttpRequest.BodyPublishers.noBody())
                .build();

        var response = client.send(request, HttpResponse.BodyHandlers.discarding());
        if (response.statusCode() != 200) throw new IOException("Failed to get metadata");

        long size = Long.parseLong(response.headers().firstValue("x-file-size").orElseThrow());
        String sha = response.headers().firstValue("x-full-checksum").orElseThrow();
        return new FileMetadata(size, sha);
    }

    private void downloadAndVerifyChunk(String fileId, long offset, long totalSize,
                                        Path outputFile, AtomicLong counter, Path progressFile) {
        while (true) { // Auto-retry loop
            try {
                var request = HttpRequest.newBuilder()
                        .uri(URI.create(baseUrl + "/api/v1/files/" + fileId + "/download?offset=" + offset))
                        .header("Authorization", "Bearer " + token)
                        .timeout(Duration.ofMinutes(10))
                        .GET()
                        .build();

                var response = client.send(request, HttpResponse.BodyHandlers.ofByteArray());
                if (response.statusCode() != 206) {
                    throw new IOException("Expected 206 Partial Content, got " + response.statusCode());
                }

                byte[] data = response.body();

                // Verify part checksum before writing
                String serverChecksum = response.headers().firstValue("x-part-checksum").orElseThrow();
                String clientChecksum = Base64.getEncoder()
                        .encodeToString(MessageDigest.getInstance("SHA-256").digest(data));

                if (!serverChecksum.equals(clientChecksum)) {
                    throw new IOException("Part checksum mismatch at offset " + offset);
                }

                // Write chunk atomically to correct position
                try (RandomAccessFile raf = new RandomAccessFile(outputFile.toFile(), "rw")) {
                    raf.seek(offset);
                    raf.write(data);
                }

                // Update progress
                counter.addAndGet(data.length);
                appendProgress(progressFile, offset);

                return; // Success — exit retry loop

            } catch (Exception e) {
                System.err.printf("Chunk %d failed — retrying: %s%n", offset, e.getMessage());
                try { Thread.sleep(2000); } catch (InterruptedException ie) { Thread.currentThread().interrupt(); }
            }
        }
    }

    private synchronized void appendProgress(Path file, long offset) throws IOException {
        Files.writeString(file, offset + "\n", StandardOpenOption.CREATE, StandardOpenOption.APPEND);
    }

    private Set<Long> loadCompletedChunks(Path file) throws IOException {
        if (!Files.exists(file)) return new HashSet<>();
        return Files.lines(file)
                .map(String::trim)
                .filter(s -> !s.isEmpty())
                .map(Long::parseLong)
                .collect(Collectors.toSet());
    }

    private String computeFileSha256(Path path) throws Exception {
        MessageDigest digest = MessageDigest.getInstance("SHA-256");
        try (InputStream is = Files.newInputStream(path)) {
            byte[] buffer = new byte[8192];
            int read;
            while ((read = is.read(buffer)) != -1) {
                digest.update(buffer, 0, read);
            }
        }
        return Base64.getEncoder().encodeToString(digest.digest());
    }

    private String formatBytes(long bytes) {
        String[] units = {"B", "KB", "MB", "GB", "TB"};
        int unit = 0;
        double size = bytes;
        while (size >= 1024 && unit < units.length - 1) {
            size /= 1024.0;
            unit++;
        }
        return String.format("%.2f %s", size, units[unit]);
    }

    private String formatDuration(Duration d) {
        long s = d.getSeconds();
        return String.format("%d min %d sec", s / 60, s % 60);
    }

    // MAIN — Run as standalone Java app
    public static void main(String[] args) throws Exception {
        new SecureParallelDownloader(
                "https://api.yourcompany.com",
                "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
                32
        ).download("research-model-v5", Path.of("model-v5.bin"));
    }
}
